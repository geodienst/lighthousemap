<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>Lighthouses</title>
		<link rel="stylesheet" href="https://unpkg.com/leaflet@1.2.0/dist/leaflet.css"
		integrity="sha512-M2wvCLH6DSRazYeZRIm1JnYyh22purTM+FDB5CsyxtQJYeKq83arPe5wgbNmcFXGqiSH2XR8dT/fJISVA1r/zQ=="
		crossorigin=""/>
		<style>
			html, body {
				margin: 0;
				padding: 0;
				height: 100%;
				font: 12px/16px sans-serif;
				color: white;
			}

			#seamap {
				width: 100%;
				height: 100%;
			}
			
			#controls {
				position: fixed;
				bottom: 0;
				left: 0;
				z-index: 1000;
			}
			
			#seamap .leaflet-control-attribution,
			#controls {
				margin: 10px;
				font-size: 12px;
				color: #ccc;
				background: none;
				text-shadow: 0px 0px 2px black;
			}
			
			#seamap .leaflet-control-attribution a {
				color: inherit;
				text-decoration: underline;
			}
		</style>
	</head>
	<body>
		<div id="seamap"></div>
		<div id="controls">
			<label>
				<input name="real-colors" type="checkbox">
				Show real colors
			</label>
		</div>
		<script id="seamap-query" type="text/x-overpass">
			[out:json][timeout:25];
			// gather results
			(
			  // query part for: “"seamark:light:sequence"=*”
			  node["seamark:light:sequence"]({{bbox}});
			  way["seamark:light:sequence"]({{bbox}});
			  relation["seamark:light:sequence"]({{bbox}});
			);
			// print results
			out body;
			>;
			out skel qt;
		</script>
		<script id="seamap-wikidata-query" type="text/x-sparql">
			SELECT ?item ?itemLabel ?location ?height ?focalHeight ?sequence
			WHERE 
			{
			  ?item wdt:P31 wd:Q39715.
			  ?item wdt:P625 ?location.
			  OPTIONAL {
				?item wdt:P2048 ?height.
				?item wdt:P2923 ?focalHeight.
				?item wdt:P1030 ?sequence.
			  }
			  SERVICE wikibase:label { bd:serviceParam wikibase:language "[AUTO_LANGUAGE],en". }
			}
		</script>
		<script src="https://unpkg.com/leaflet@1.6.0/dist/leaflet-src.js"></script>
		<script src="https://unpkg.com/osmtogeojson@3.0.0-beta.2/osmtogeojson.js"
		  integrity="sha384-O1DMEF/gKYhLsICYtozkRWjEr9OfkZzVawUjyOPtevnKB2S1BegNJO0R251Pfuwz"
		  crossorigin=""></script>
		<script src="https://unpkg.com/rbush@2.0.1/rbush.js"></script>
		<script src="https://unpkg.com/@turf/turf@3.5.2/turf.min.js"></script>
		<script src="leaflet.indexedfeaturelayer.js"></script>
		<script src="leaflet.light.js"></script>
		<script>
			// map
			let map = L.map('seamap', {attributionControl: false})
				.setView([55.7, -3.7], 6)
				.addControl(L.control.attribution({
					position: 'bottomright',
					prefix: 'PJ, based on an original by <a href="https://www.geodienst.xyz/">Geodienst</a>'
				}));

			// background layer

//			nice layer
			// L.tileLayer('https://tiles.stadiamaps.com/tiles/alidade_smooth_dark/{z}/{x}/{y}{r}.png', {
			// 	maxZoom: 20,
			// 	attribution: '&copy; <a href="https://stadiamaps.com/">Stadia Maps</a>, &copy; <a href="https://openmaptiles.org/">OpenMapTiles</a> &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors'
			// }).addTo(map);

			// simple layer
			L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png', {
				detectRetina: true,
				attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, &copy; <a href="http://cartodb.com/attributions">CartoDB</a>'
			}).addTo(map);

			let bounds = map.getBounds();

			function bbox(bounds) {
				let ne = bounds.getNorthEast();
				let sw = bounds.getSouthWest();
				return [sw.lat, sw.lng, ne.lat, ne.lng]
			}

			// query to get lighthouse data from OSM. Not used - just reads from a local json file instead
			let query = document.getElementById('seamap-query').textContent
				.replace(/\{\{bbox\}\}/g, bbox(bounds).join(','));

			// // Query the entire world
			// bounds = [-90, -180, 90, 180]

			// let query = document.getElementById('seamap-query').textContent
			// 	.replace(/\{\{bbox\}\}/g, bounds.join(','));

			let url = 'https://www.overpass-api.de/api/interpreter?data=' + encodeURIComponent(query);

			url = 'data_just2.json'; // For testing
			//url = 'data_pj_recent.json'; // For testing

			let data = fetch(url)
				.then(req => req.json())
				.then(json => osmtogeojson(json))
				.then(json => ({
					type: json.type,
					features: json.features.map(feature => {
						return feature.geometry.type == 'Polygon'
							? Object.assign({}, feature, {geometry: turf.centroid(feature).geometry})
							: feature;
					})
				}));

			let flashing_lights = data.then(geojson => {
				return L.indexedGeoJSON(null, {
					pointToLayer: function(feat, latlng) {
						let sequence;

						try {
							sequence = L.Light.sequence(feat.properties.tags, '#FF0');
						} catch (e) {
							console.error('Error parsing sequence: %s', e, feat.properties.tags);

							// Fallback sequence flashing 1s on, 1s off
							sequence = L.Light.sequence({
								'seamark:light:sequence': '1+(1)'
							});
						}

						return new L.Light(latlng, {
							interactive: false,
							title: feat.properties.tags['name'],
							// PJ: use light:1 if multiple lights
							// assumes range is in km. Is this right?
							// no - it's nautical miles - see https://wiki.openstreetmap.org/wiki/Seamarks/Lights
							// radius: (parseFloat(feat.properties.tags['seamark:light:range'], 10) || 1) * 1000,
							radius: (parseFloat(feat.properties.tags['seamark:light:range'], 10) || parseFloat(feat.properties.tags['seamark:light:1:range'], 10) || 1) * 1000,
							sequence: sequence,
							stroke: false,
							fillOpacity: 0.7,
							fill: !!sequence.state(0),
							fillColor: sequence.state(0)
						});
					}
				}).addTo(map).addData(geojson);
			});


			//add a sample SVG layer to the map
			// first, build the SVG
			var svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
			svgElement.setAttribute('xmlns', "http://www.w3.org/2000/svg");
			svgElement.setAttribute('viewBox', "0 0 200 200");
			svgPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
			// set the path to draw a white heart
			svgPath.setAttribute('d', 'M 10,30 A 20,20 0,0,1 50,30 A 20,20 0,0,1 90,30 Q 90,60 50,90 Q 10,60 10,30 z');
			svgPath.setAttribute('id', 'heart');
			svgPath.setAttribute('style', "fill:white");
			svgElement.appendChild(svgPath);

			var svgElementBounds = [ [ 53, -3 ], [ 52, -1 ] ];
			// add it to the map
			L.svgOverlay(svgElement, svgElementBounds).addTo(map);

			// add a sample Canvas layer to the map
			// (code pinched from lights_example.html)
			let lighthouse_data = {
				'name': 'test lighthouse',
				'type': 'lighthouse',
				'xpos': 200,
				'ypos': 200,
				'sectors': [
					{'start': 1, 'end': 30, "colour": "green", "range": 20},
					{'start': 30, 'end': 220, "colour": "white", "range": 30},
					{'start': 220, 'end': 280, "colour": "red", "range": 20}
				]
			};

			// get the canvas on which to draw



		    // function to draw a lighthouse
		    let draw_light = function(lighthouse, context) {

		        var origin_x = lighthouse.xpos;
		        var origin_y = lighthouse.ypos;

		        // draw a light sector between start and end bearings, with radius = range and specified colour
		        let draw_sector = function (light_to_draw) {
		            //console.log(light_to_draw.start, light_to_draw.end, light_to_draw.range, light_to_draw.colour, origin_x, origin_y);
		            
		            // start and end are bearings TO the light. We need bearing FROM the light = 180+start % 360.
		            // SVG arc angles are measured from the y=0 line i.e. 0deg = right. So need to subtract 90deg to get direction from north

		            // is it a circle
		            var start_from_deg;
		            var end_from_deg;
		            
		            if (light_to_draw.start == '0' && light_to_draw.end == '360') {
		                start_from_deg = 0;
		                end_from_deg = 360;
		            }
		            else {            
		                start_from_deg = (90 + parseInt(light_to_draw.start)) % 360;
		                end_from_deg = (90 + parseInt(light_to_draw.end)) % 360;
		            }
		           //console.log('pj','angles', light_to_draw.start, light_to_draw.end, start_from_deg, end_from_deg);

		            var angle_s = start_from_deg / 180 * Math.PI;
		            var angle_e = end_from_deg / 180 * Math.PI;
		            var radius = light_to_draw.range * 8;

		            context.beginPath();
		            context.moveTo(origin_x, origin_y);
		            context.arc(origin_x,origin_y,radius,angle_s,angle_e);
		            context.lineTo(origin_x, origin_y);
		            context.closePath;
		            
		            context.fillStyle = (light_to_draw.colour == 'white' ? 'white' : light_to_draw.colour);
		            context.fill();
		        };
		        
		        lighthouse.sectors.forEach(draw_sector);

		        // put a dot where the lighthouse is
		        context.beginPath();
		        context.arc(origin_x, origin_y, 5, 0, 2 * Math.PI);
		        context.closePath;
		        context.fillStyle = "orange";
		        context.fill();
		    };

		    // get the user input
			let useRealColors = true;
			document.querySelector('input[name=real-colors]').checked = useRealColors;
			document.querySelector('input[name=real-colors]').addEventListener('change', function(e) {
				useRealColors = this.checked;
			});

			// flash the lights
			flashing_lights.then(layer => {
				let draw = function(t) {
					layer.eachVisibleLayer(marker => {
						var state = false
						try{
							var state = marker.options.sequence.state(t);
							marker.setColor(state ? (useRealColors ? state : '#FF0') : false);
						} catch(e){
							console.error(e)
						}
						
					});
				};

				let update = function(t) {
					draw(t / 1000);
					requestAnimationFrame(update);
				};
				update(0);
			}).catch(e => console.error(e));

			flashing_lights.catch(e => console.error(e));

		</script>
	</body>
</html>
