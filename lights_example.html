<!DOCTYPE html>
<html>
<head>
     <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
   integrity="sha512-xodZBNTC5n17Xt2atTPuE1HxjVMSvLVW9ocqUKLsCC5CXdbqCmblAshOMAS6/keqq/sMZMZ19scR4PsZChSR7A=="
   crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"
   integrity="sha512-XQoYMqMTK8LvdxXYG3nZ448hOEQiglfqkJs1NOQV44cWnUrBc8PkAOcXy20w0vlaXaVUearIOBhiXZ5V3ynxwA=="
   crossorigin=""></script>   
    <script src="https://unpkg.com/@turf/turf@3.5.2/turf.min.js"></script>
    <script src="chroma/chroma.min.js"></script>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            font: 12px/16px sans-serif;
            color: white;
        }

        #mapdiv {
            width: 100%;
            height: 100%;
            position: fixed;
        }
        
/*        #drawcanvas {
            width: 100%;
            height: 100%;
            position: fixed;
        }
*/        
        #controls {
            position: fixed;
            bottom: 0;
            left: 0;
            z-index: 1000;
        }
        
        #seamap .leaflet-control-attribution,
        #controls {
            margin: 10px;
            font-size: 12px;
            color: #ccc;
            background: none;
            text-shadow: 0px 0px 2px black;
        }
        
        #seamap .leaflet-control-attribution a {
            color: inherit;
            text-decoration: underline;
        }
    </style>
</head>
<body>
<!--     <div id="mapcontainer"> -->
        <div id="mapdiv"></div>
       <!--  <canvas id="drawcanvas" width="400" height="400"></canvas> -->
 <!--    </div>
 --><script>
    // this mangles a set of tags from OSM data into an array of objects that looks like light_data below.
    // It's very ramshackle and plenty of room for tidying and improvement.

    const NM_IN_METRES = 1852; // https://en.wikipedia.org/wiki/Nautical_mile

    // copy in here the geojson for a lighthouse from lights_geojson.json 
    var geojson = {
            // "type": "Feature",
            // "id": "way/426352856",
            // "properties": {
            //     "building": "yes",
            //     "man_made": "lighthouse",
            //     "name": "Carraig Fhada Lighthouse",
            //     "seamark:light:1:character": "Fl",
            //     "seamark:light:1:colour": "white",
            //     "seamark:light:1:height": "20",
            //     "seamark:light:1:period": "3",
            //     "seamark:light:1:range": "8",
            //     "seamark:light:1:sector_end": "248",
            //     "seamark:light:1:sector_start": "150",
            //     "seamark:light:1:sequence": "0.3+(2.7)",
            //     "seamark:light:2:character": "Fl",
            //     "seamark:light:2:colour": "green",
            //     "seamark:light:2:height": "20",
            //     "seamark:light:2:period": "3",
            //     "seamark:light:2:range": "6",
            //     "seamark:light:2:sector_end": "311",
            //     "seamark:light:2:sector_start": "248",
            //     "seamark:light:2:sequence": "0.3+(2.7)",
            //     "seamark:light:3:character": "Fl",
            //     "seamark:light:3:colour": "white",
            //     "seamark:light:3:height": "20",
            //     "seamark:light:3:period": "3",
            //     "seamark:light:3:range": "8",
            //     "seamark:light:3:sector_end": "340",
            //     "seamark:light:3:sector_start": "311",
            //     "seamark:light:3:sequence": "0.3+(2.7)",
            //     "seamark:light:4:character": "Fl",
            //     "seamark:light:4:colour": "red",
            //     "seamark:light:4:height": "20",
            //     "seamark:light:4:period": "3",
            //     "seamark:light:4:range": "6",
            //     "seamark:light:4:sector_end": "50",
            //     "seamark:light:4:sector_start": "340",
            //     "seamark:light:4:sequence": "0.3+(2.7)",
            //     "seamark:light:reference": "A 4248",
            //     "seamark:name": "Carraig Fhada",
            //     "seamark:type": "light_minor",
            //     "wikidata": "Q1368154",
            //     "id": "way/426352856"
            // },
            // "geometry": {
            //     "type": "Polygon",
            //     "coordinates": [
            //         [
            //             [
            //                 -6.2116972,
            //                 55.6202867
            //             ],
            //             [
            //                 -6.2116567,
            //                 55.6202345
            //             ],
            //             [
            //                 -6.2115656,
            //                 55.620257
            //             ],
            //             [
            //                 -6.2116061,
            //                 55.6203092
            //             ],
            //             [
            //                 -6.2116972,
            //                 55.6202867
            //             ]
            //         ]
            //     ]
            // }
            "type": "Feature",
            "id": "node/427582786",
            "properties": {
                "man_made": "lighthouse",
                "name": "Southwold Lighthouse",
                "seamark:landmark:height": "31",
                "seamark:light:1:character": "Fl",
                "seamark:light:1:colour": "white",
                "seamark:light:1:group": "4",
                "seamark:light:1:height": "37",
                "seamark:light:1:period": "20",
                "seamark:light:1:range": "16",
                "seamark:light:1:sector_end": "1.0",
                "seamark:light:1:sector_start": "215.0",
                "seamark:light:1:sequence": "0.5+(1)+0.5+(1)+0.5+(1)+0.5+(15)",
                "seamark:light:2:character": "Fl",
                "seamark:light:2:colour": "red",
                "seamark:light:2:group": "4",
                "seamark:light:2:height": "37",
                "seamark:light:2:period": "20",
                "seamark:light:2:range": "12",
                "seamark:light:2:sector_end": "215.0",
                "seamark:light:2:sector_start": "204.0",
                "seamark:light:2:sequence": "0.5+(1)+0.5+(1)+0.5+(1)+0.5+(15)",
                "seamark:light:3:character": "Fl",
                "seamark:light:3:colour": "red",
                "seamark:light:3:group": "4",
                "seamark:light:3:height": "37",
                "seamark:light:3:period": "20",
                "seamark:light:3:range": "12",
                "seamark:light:3:sector_end": "32.5",
                "seamark:light:3:sector_start": "1.0",
                "seamark:light:3:sequence": "0.5+(1)+0.5+(1)+0.5+(1)+0.5+(15)",
                "seamark:light:reference": "A 2272",
                "seamark:name": "Southwold",
                "seamark:radio_station:category": "ais",
                "seamark:radio_station:mmsi": "992351019",
                "seamark:type": "landmark",
                "wikidata": "Q7571483",
                "id": "node/427582786"
            },
            "geometry": {
                "type": "Point",
                "coordinates": [
                    1.6813393,
                    52.3272264
                ]
            }
     };

    // get the entries where tags match "seamark:light:i:<something>" and create an object of {<something>: value ...} entries
    let light_entry = function (tags, light_seq) {
        // create regexp using light_seq
        let re = new RegExp("seamark:light:" + light_seq.toString() + ':(.+)$');

        // get the key-value pairs which match the regex - of the form "period", "3"
        the_entries = Object.entries(tags).filter((the_entry) => re.test(the_entry[0]));

        // process these entries into an object
        let one_light_data = {};
        the_entries.forEach(entry => {
            let new_key = entry[0].match(re);
            // change the names of a couple of them to match the expected naming
            switch(new_key[1]) {
                case 'sector_start':
                    key = 'start';
                    break;
                case 'sector_end':
                    key = 'end';
                    break;
                default:
                    key = new_key[1];
            } 
            one_light_data[key] = entry[1];
        });
        return one_light_data;
    };

    let lighthouse_data = function (geojson) {

         // iterate through all the lights to build a light_data object
        var light_data = [];

        var tags = geojson.properties;

        for (let light_seq = 1; light_seq < 9; light_seq++){
            let this_light = light_entry(tags, light_seq);
            if (Object.keys(this_light).length > 0)
                {
                    this_light.range = !this_light.range ? 5.0 : this_light.range;

                    light_data.push(this_light);}
            else {break;}
        }

        // if this didn't result in anything, the lighthouse only has one light.
        if (!light_data.length) {
            // now we are just looking for tags looking like seamark:light:<something>
            let re2 = new RegExp("seamark:light:(.+)$");
            // get the key-value pairs
            the_entries = Object.entries(tags).filter((the_entry) => re2.test(the_entry[0]));

            // process these entries into an object
            let one_light_data = {};
            the_entries.forEach(entry => {
                let new_key = entry[0].match(re2);
                one_light_data[new_key[1]] = entry[1];
            });

            //check for missing range and default
            one_light_data.range = !one_light_data.range ? 5.0 : one_light_data.range;

            // no start or end angles, so need to provide these to draw a circle: 0, 360
            one_light_data.start = '0';
            one_light_data.end = '360';

            light_data.push(one_light_data);
        }

        // get the location of the lighthouse as a latlong, using the centre if it's a polygon
        var latlong = L.GeoJSON.coordsToLatLng(
            geojson.geometry.type == "Polygon" 
            ? turf.centroid(geojson.geometry).geometry.coordinates
            : geojson.geometry.coordinates
            );

        // populate some other tags of the lighthouse
        var the_lighthouse = {};
        the_lighthouse.name = tags['seamark:name'] || tags['name'];
        the_lighthouse.type = tags['seamark:type'];
        the_lighthouse.latlong = latlong; 
        the_lighthouse.sectors = light_data;
        the_lighthouse.range_nm = light_data.reduce((prev, sector) => Math.max(prev, sector.range),0);  // max of the sector ranges
        the_lighthouse.sequence = tags['seamark:light:sequence'] || tags['seamark:light:1:sequence'];
        // default if no sequence found
        the_lighthouse.sequence = !the_lighthouse.sequence ? "1+(1)" : the_lighthouse.sequence;

        // if it's an Iso light, the sequence is missing but should be period/2+(period/2)

 
        // build a sequence array from the light sequence string
        // it's series of comma- or plus-separated tokens comprising numbers
        // which are in brackets if dark, not if light
        // split the sequence
        var seq_split = the_lighthouse.sequence.replace(/,/g,'+').split('+');
        var seq_steps = seq_split.map(element => {
            if(element.substring(0, 1) == '('){
                return [false, Number(element.substring(1, element.length-1))];
            }
            else {
                return ['yes', Number(element)];
            }
        });

        // the sequence object is a duration and the array of steps
        var the_duration = seq_steps.reduce((total, step) => total+step[1], 0);
        var the_sequence = {
            duration: the_duration,
            steps: seq_steps
        };
        the_lighthouse.sequence_data = the_sequence;

        return the_lighthouse;
    };

    // draw a lighthouse
    let draw_light = function(the_time, lighthouse, ctx) {

        // draw the light in the middle of the canvas (which should be where we want it to go)


        var origin_x = ctx.canvas.width / 2;
        var origin_y = ctx.canvas.height / 2;
        var max_radius = Math.min(origin_x, origin_y);  // in pixels
        var max_range = lighthouse.range_nm;

        //debugger;

        ctx.save(); // keep the context so we can unpick the clipping path at the end

        // draw a light sector between start and end bearings, with radius = range and specified colour
        let draw_sector = function (light_to_draw) {
            //console.log(light_to_draw.start, light_to_draw.end, light_to_draw.range, light_to_draw.colour, origin_x, origin_y);
            
            // start and end are bearings TO the light. We need bearing FROM the light = 180+start % 360.
            // SVG arc angles are measured from the y=0 line i.e. 0deg = right. So need to subtract 90deg to get direction from north
            //console.log('pj','sector', light_to_draw, max_radius, max_range);

            // is it a circle
            var start_from_deg;
            var end_from_deg;
            
            if (light_to_draw.start == '0' && light_to_draw.end == '360') {
                start_from_deg = 0;
                end_from_deg = 360;
            }
            else {            
                start_from_deg = (90 + parseInt(light_to_draw.start)) % 360;
                end_from_deg = (90 + parseInt(light_to_draw.end)) % 360;
            }
           //console.log('pj','angles', light_to_draw.start, light_to_draw.end, start_from_deg, end_from_deg);

            var angle_s = start_from_deg / 180 * Math.PI;
            var angle_e = end_from_deg / 180 * Math.PI;
            var radius = light_to_draw.range * max_radius / max_range; // in proportion to longest range sector

            //console.log('pj', 'sector radius', radius);

            ctx.beginPath();
            ctx.moveTo(origin_x, origin_y);
            ctx.arc(origin_x,origin_y,radius,angle_s,angle_e);
            ctx.lineTo(origin_x, origin_y);
            ctx.closePath();

            // do a gradient fill that fades from the centre to the range of the light
            // first colour is the specified colour; the second is that same, but transparent
            var start_colour = chroma(light_to_draw.colour == 'white' ? 'white' : light_to_draw.colour).alpha(0.7);
            var end_colour = chroma(start_colour).alpha(0.0);
            //console.log('pj', 'mapped colours', start_colour, end_colour);


            var grd = ctx.createRadialGradient(origin_x, origin_y, 0, origin_x, origin_y, radius);
            grd.addColorStop(0, start_colour);
            grd.addColorStop(1, end_colour);
            ctx.fillStyle = (grd);
//            ctx.fillStyle = (start_colour);
            ctx.fill();
        };

        // for the rotating light, we ignore the colour (that's set by the underlying sector) 
        // and just use the durations of the segments where it's false
        // this generates a set of clipping path sectors on top of which we draw the sectors

        // first up, clear what's already been drawn
        ctx.fillStyle = "#303030";
        ctx.fillRect(0, 0, c.width, c.height);

        var the_sequence = lighthouse.sequence_data;

        // rotation angle based on time
        var rotation_angle = ((the_time + the_sequence.offset) / the_sequence.duration * 360) % 360;

        // build the clipping path based on the light sequence steps
        var start_angle = 0;
        ctx.beginPath();
        for (let step = 0; step < the_sequence.steps.length; step++) {
            var clip_angle_s = (rotation_angle + start_angle) % 360;
            var clip_angle_e = (rotation_angle + start_angle + the_sequence.steps[step][1] * 360 / the_sequence.duration) % 360;

            // draw a sector for each illuminated bit
            if (the_sequence.steps[step][0]) {
                ctx.moveTo(origin_x, origin_y);
                ctx.arc(origin_x,origin_y, max_radius, clip_angle_s / 180 * Math.PI, clip_angle_e / 180 * Math.PI);
                ctx.lineTo(origin_x, origin_y);
            }
            start_angle = start_angle + the_sequence.steps[step][1] * 360 / the_sequence.duration;
        };
        ctx.clip();

        // draw the lighthouse sectors on top of clipping path to limit where they shine
        //console.log('pj', 'sectors', max_radius, lighthouse.range_nm);
        lighthouse.sectors.forEach(draw_sector);

        // put a dot where the lighthouse is. Do restore() to clear the clip path so we get the whole dot.
        ctx.restore();
        // ctx.beginPath();
        // ctx.arc(origin_x, origin_y, 5, 0, 2 * Math.PI);
        // ctx.closePath();
        // ctx.fillStyle = "white";
        // ctx.fill();
    };

    // get the lighthouse from the data
    var my_lighthouse = lighthouse_data(geojson);

    var map = L.map('mapdiv', {
      maxZoom: 18,
      preferCanvas: true
    }).setView([55.7, -3.7], 6);

    //background layer
    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png', {
        detectRetina: true,
        attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, &copy; <a href="http://cartodb.com/attributions">CartoDB</a>'
    }).addTo(map);
/*
    // add a circle to the map to represent the lighthouse
    new L.Circle(
        my_lighthouse.latlong,
        {
            radius: my_lighthouse.range_nm * NM_IN_METRES, 
            fillColor: "white",
            fillOpacity: 0.3,
            stroke: false,
            interactive: false
        }
    ).addTo(map);

    // add a marker and a popup for the lighthouse exact position
    new L.CircleMarker(
        my_lighthouse.latlong,
        {
            radius: 3,
            fillColor: "white",
            stroke: false,
            fillOpacity: 0.9,
            color: false
        }
    ).addTo(map).bindPopup(my_lighthouse.name + ", range " + my_lighthouse.range_nm + " nautical miles");
*/
    // update the Canvas to handle how to draw a lighthouse
    L.Canvas.include({

       _updateLighthouse: function(layer, t) {

        // if (!this._drawing || layer._empty()) {
        //     console.log('not drawing');
        //   return;
        // }

        var p = layer._point,
          ctx = this._ctx,
          r = layer._radius;
          width = this.width;
          height = this.height;
        var centre_opacity = layer.options.centre_opacity;
        var edge_opacity = layer.options.edge_opacity;
        var max_range = layer.options.range_nm;
        var offset = layer.options.time_offset;
  
        let draw_light_sector = function (light_to_draw) {
            // is it a circle?
            var start_from_deg;
            var end_from_deg;
            
            if (light_to_draw.start == '0' && light_to_draw.end == '360') {
                start_from_deg = 0;
                end_from_deg = 360;
            }
            else {            
                start_from_deg = (90 + parseInt(light_to_draw.start)) % 360;
                end_from_deg = (90 + parseInt(light_to_draw.end)) % 360;
            }
            var angle_s = start_from_deg / 180 * Math.PI;
            var angle_e = end_from_deg / 180 * Math.PI;
            var radius = light_to_draw.range * r / max_range; // in proportion to longest range sector

            // draw the sector
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.arc(p.x, p.y, radius, angle_s, angle_e);
            ctx.lineTo(p.x, p.y);
            ctx.closePath();

            // do a gradient fill
            var grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, radius);
            grad.addColorStop(0, chroma(light_to_draw.colour).alpha(centre_opacity));
            grad.addColorStop(1, chroma(light_to_draw.colour).alpha(edge_opacity));
            ctx.fillStyle = (grad);
            ctx.fill();
        };

        // draw the rotating shutters which define the lighthouse sequence, as a clipping path
        let draw_rotating_shutters_clip_path = function(sequence, t) {

            var the_time = t ? t : 0;


            // first up, clear what's already been drawn
            //ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

            // rotation angle in degrees based on time and duration
            var rotation_angle = ((the_time + sequence.time_offset) / sequence.duration * 360) % 360;
            //console.log('time', the_time, rotation_angle);

            // build the clipping path based on the light sequence steps
            var start_angle = 0;
            ctx.beginPath();
            for (let step = 0; step < sequence.steps.length; step++) {
                var clip_angle_s = (rotation_angle + start_angle) % 360;
                var clip_angle_e = (rotation_angle + start_angle + sequence.steps[step][1] * 360 / sequence.duration) % 360;
                //console.log(clip_angle_s, clip_angle_e, step);
                // draw a sector for each illuminated bit
                if (sequence.steps[step][0]) {
                    ctx.moveTo(p.x, p.y);
                    ctx.arc(p.x, p.y, r, clip_angle_s / 180 * Math.PI, clip_angle_e / 180 * Math.PI);
                    ctx.lineTo(p.x, p.y);
                }
                start_angle = start_angle + sequence.steps[step][1] * 360 / sequence.duration;
            };
            ctx.clip();
        };

        ctx.save();
        // draw the shutters clip path
        draw_rotating_shutters_clip_path(layer.options.sequence_data, t);
        // draw the sectors of the lighthouse  
        layer.options.sectors.forEach(draw_light_sector);
        ctx.restore(); // to clear the clip path

        // draw a dot where the lighthouse is


      }


    });

    L.Lighthouse = L.Circle.extend({
        initialize: function(latlng, options) {
            options.radius = options.range_nm * NM_IN_METRES;
            options.sequence_data.time_offset = Math.random() * options.sequence_data.duration;
            options.interactive = false;
            options.centre_opacity = 0.6;
            options.edge_opacity = 0.0;
 
            // and call the circle initialiser
            L.Circle.prototype.initialize.call(this, latlng, options, {});
        },

        _updatePath: function(t) {
            //console.log('in update');
            this._renderer._updateLighthouse(this, t);
        }

      });

    // draw the lighthouse on the map
    the_light = new L.Lighthouse(my_lighthouse.latlong, my_lighthouse).addTo(map);

    // draw a whole bunch of lighthouses
    url = 'lights_geojson.json'; // For testing
    //url = 'data_pj_recent.json'; // For testing

    let the_lights = fetch(url)
        .then(req => req.json())
        .then(geojson => {
            //console.log('features', geojson.features);

            var lights = [];

            geojson.features.forEach(feature => {

                // console.log('feature', feature);
                lights.push(lighthouse_data(feature));});

            //console.log('lights', lights);
            return lights;
        })
        .then(lights => {
            var maplights = [];

            lights.forEach(light => {
                //console.log('light', light);
                maplights.push(new L.Lighthouse(light.latlong, light).addTo(map));
            });

             console.log(maplights);
             return maplights;
            });



    //console.log(data);    

    // convert json object into array of 

    // let lights = data.features.then(feature => {
    //     console.log('feature', feature);
    //     return lighthouse_data(feature);
    // });

   // console.log('lights', lights);


        // .then(geojson => {

        //     console.log('geojson', geojson);
        //     return lighthouse_data(geojson)});

    //console.log('pj', 'lighthouses', lighthouses);

    // animate the lighthouse
    // call the draw_light function repeatedly using requestAnimationFrame
/*    let update_the_light = function(t){
       
        the_light._updatePath(t / 1000);
        requestAnimationFrame(update_the_light);
    };
    update_the_light(0);
*/
</script> 
</body>
</html>

