<!DOCTYPE html>
<html>
<body>
    <canvas id="myCanvas" width="600" height="600" style="border:1px solid #d3d3d3;">
    Your browser does not support the HTML canvas tag.</canvas>
<script src="chroma/chroma.min.js"></script>
<script>
    // this mangles a set of tags from OSM data into an array of objects that looks like light_data below.
    var tags = {
                "man_made": "lighthouse",
                "name": "Southwold Lighthouse",
                "seamark:landmark:height": "31",
                "seamark:light:1:character": "Fl",
                "seamark:light:1:colour": "white",
                "seamark:light:1:group": "4",
                "seamark:light:1:height": "37",
                "seamark:light:1:period": "20",
                "seamark:light:1:range": "16",
                "seamark:light:1:sector_end": "1.0",
                "seamark:light:1:sector_start": "215.0",
                "seamark:light:1:sequence": "0.5+(1)+0.5+(1)+0.5+(1)+0.5+(15)",
                "seamark:light:2:character": "Fl",
                "seamark:light:2:colour": "red",
                "seamark:light:2:group": "4",
                "seamark:light:2:height": "37",
                "seamark:light:2:period": "20",
                "seamark:light:2:range": "12",
                "seamark:light:2:sector_end": "215.0",
                "seamark:light:2:sector_start": "204.0",
                "seamark:light:2:sequence": "0.5+(1)+0.5+(1)+0.5+(1)+0.5+(15)",
                "seamark:light:3:character": "Fl",
                "seamark:light:3:colour": "red",
                "seamark:light:3:group": "4",
                "seamark:light:3:height": "37",
                "seamark:light:3:period": "20",
                "seamark:light:3:range": "12",
                "seamark:light:3:sector_end": "32.5",
                "seamark:light:3:sector_start": "1.0",
                "seamark:light:3:sequence": "0.5+(1)+0.5+(1)+0.5+(1)+0.5+(15)",
                "seamark:light:reference": "A 2272",
                "seamark:name": "Southwold",
                "seamark:radio_station:category": "ais",
                "seamark:radio_station:mmsi": "992351019",
                "seamark:type": "landmark",
                "wikidata": "Q7571483",
                "id": "node/427582786"
    };

    // get the entries where tags match "seamark:light:i:<something>" and create an object of {<something>: value ...} entries
    let light_entry = function (tags, light_seq) {
        // create regexp using light_seq
        let re = new RegExp("seamark:light:" + light_seq.toString() + ':(.+)$');

        // get the key-value pairs which match the regex - of the form "period", "3"
        the_entries = Object.entries(tags).filter((the_entry) => re.test(the_entry[0]));

        // process these entries into an object
        let one_light_data = {};
        the_entries.forEach(entry => {
            let new_key = entry[0].match(re);
            // change the names of a couple of them to match the expected naming
            switch(new_key[1]) {
                case 'sector_start':
                    key = 'start';
                    break;
                case 'sector_end':
                    key = 'end';
                    break;
                default:
                    key = new_key[1];
            } 
            one_light_data[key] = entry[1];
        });
        return one_light_data;
    };

     // iterate through all the lights to build a light_data object
    var light_data = [];

    for (let light_seq = 1; light_seq < 9; light_seq++){
        let this_light = light_entry(tags, light_seq);
        //console.log('pj','this light', light_seq, this_light);
        if (Object.keys(this_light).length > 0)
            {light_data.push(this_light);}
        else {break;}
    }

    // if this didn't result in anything, the lighthouse only has one light.
    if (!light_data.length) {
        // now we are just looking for tags looking like seamark:light:<something>
        let re2 = new RegExp("seamark:light:(.+)$");
        // get the key-value pairs
        the_entries = Object.entries(tags).filter((the_entry) => re2.test(the_entry[0]));

        // process these entries into an object
        let one_light_data = {};
        the_entries.forEach(entry => {
            let new_key = entry[0].match(re2);
            one_light_data[new_key[1]] = entry[1];
        });

        // no start or end angles, so need to provide these to draw a circle: 0, 360
        one_light_data.start = '0';
        one_light_data.end = '360';
        //console.log('pj', 'single light data', one_light_data);

        light_data.push(one_light_data);
    }

   //console.log('pj', 'light_data 2', light_data);

   // populate some other tags of the lighthouse
   var the_lighthouse = {};
   the_lighthouse.name = tags['seamark:name'] || tags['name'];
   the_lighthouse.type = tags['seamark:type'];
   the_lighthouse.sectors = light_data;
   the_lighthouse.xpos = 300;
   the_lighthouse.ypos = 300;
   the_lighthouse.sequence = tags['seamark:light:sequence'] || tags['seamark:light:1:sequence'];
   //console.log('pj', 'the_lighthouse', the_lighthouse);

    // get a canvas element and fill it sort of dark grey
    var c = document.getElementById("myCanvas");
    var ctx = c.getContext("2d");
    ctx.fillStyle = "#303030";
    ctx.fillRect(0, 0, c.width, c.height);

    // draw a lighthouse
    let draw_light = function(the_time, lighthouse, context) {

        var origin_x = lighthouse.xpos;
        var origin_y = lighthouse.ypos;
        //var background = context.fillStyle;

        context.save(); // keep the context so we can unpick the clipping path at the end

        // draw a light sector between start and end bearings, with radius = range and specified colour
        let draw_sector = function (light_to_draw) {
            //console.log(light_to_draw.start, light_to_draw.end, light_to_draw.range, light_to_draw.colour, origin_x, origin_y);
            
            // start and end are bearings TO the light. We need bearing FROM the light = 180+start % 360.
            // SVG arc angles are measured from the y=0 line i.e. 0deg = right. So need to subtract 90deg to get direction from north

            // is it a circle
            var start_from_deg;
            var end_from_deg;
            
            if (light_to_draw.start == '0' && light_to_draw.end == '360') {
                start_from_deg = 0;
                end_from_deg = 360;
            }
            else {            
                start_from_deg = (90 + parseInt(light_to_draw.start)) % 360;
                end_from_deg = (90 + parseInt(light_to_draw.end)) % 360;
            }
           //console.log('pj','angles', light_to_draw.start, light_to_draw.end, start_from_deg, end_from_deg);

            var angle_s = start_from_deg / 180 * Math.PI;
            var angle_e = end_from_deg / 180 * Math.PI;
            var radius = light_to_draw.range * 16;

            context.beginPath();
            context.moveTo(origin_x, origin_y);
            context.arc(origin_x,origin_y,radius,angle_s,angle_e);
            context.lineTo(origin_x, origin_y);
            context.closePath();

            // do a gradient fill that fades from the centre to the range of the light
            // first colour is the specified colour; the second is that same, but transparent
            var start_colour = chroma(light_to_draw.colour == 'white' ? 'white' : light_to_draw.colour).alpha(0.7);
            var end_colour = chroma(start_colour).alpha(0.0);
            //console.log('pj', 'mapped colours', start_colour, end_colour);


            var grd = context.createRadialGradient(origin_x, origin_y, 0, origin_x, origin_y, radius);
            grd.addColorStop(0, start_colour);
            grd.addColorStop(1, end_colour);
            context.fillStyle = (grd);
            context.fill();
        };

       // simulate the rotating light by clipping to just the moving sector where the light shines through
        // this is rotated by an angle dependent on the time, to simulate the light rotating
        //the sequence is of the form 
        // var the_sequence = {
        //     duration: 20,
        //     offset: 0, // set to a random number when the light is drawn
        //     steps: [
        //         ['white', 0.5],
        //         [false, 1],
        //         ['white', 0.5],
        //         [false, 1],
        //         ['white', 0.5],
        //         [false, 1],
        //         ['white', 0.5],
        //         [false, 15]
        //     ]
        // };

        // build the sequence array from the light sequence string
        // it's series of plus-separated tokens comprising numbers
        // which are in brackets if dark, not if light
        // split the sequence
        var seq_split = the_lighthouse.sequence.replace(/,/g,'+').split('+');
        //console.log('pj', 'seq_split', seq_split);
        // extract the numbers using a regex, identifying whether there's a bracket or not
        var seq_steps = seq_split.map(element => {
            if(element.substring(0, 1) == '('){
                return [false, Number(element.substring(1, element.length-1))];
            }
            else {
                return ['yes', Number(element)];
            }
        });

        // the sequence object is a duration and the array of steps
        var the_sequence = {
            duration: seq_steps.reduce((total, step) => total+step[1], 0),
            steps: seq_steps
        };

        // for the rotating light, we ignore the colour (that's set by the underlying sector) 
        // and just use the durations of the segments where it's false
        // this generates a set of clipping path sectors on top of which we draw the sectors

        // first up, clear what's already been drawn
        context.fillStyle = "#303030";
        context.fillRect(0, 0, c.width, c.height);

        // clip radius = max of the sector ranges
        var clip_radius = 16 * lighthouse.sectors.reduce((prev, sector) => Math.max(prev, sector.range),0);

        // rotation angle based on time
        var rotation_angle = (the_time / the_sequence.duration * 360) % 360;

        // build the clipping path based on the light sequence steps
        var start_angle = 0;
        context.beginPath();
        for (let step = 0; step < the_sequence.steps.length; step++) {
            var clip_angle_s = (rotation_angle + start_angle) % 360;
            var clip_angle_e = (rotation_angle + start_angle + the_sequence.steps[step][1] * 360 / the_sequence.duration) % 360;

            // draw a sector for each illuminated bit
            if (the_sequence.steps[step][0]) {
                context.moveTo(origin_x, origin_y);
                context.arc(origin_x,origin_y,clip_radius,clip_angle_s / 180 * Math.PI,clip_angle_e / 180 * Math.PI);
                context.lineTo(origin_x, origin_y);
            }
            start_angle = start_angle + the_sequence.steps[step][1] * 360 / the_sequence.duration;
        };
        context.clip();

        // draw the lighthouse sectors on top of clipping path to limit where they shine
        lighthouse.sectors.forEach(draw_sector);

        // put a dot where the lighthouse is. Do restore() to clear the clip path so we get the whole dot.
        context.restore();
        context.beginPath();
        context.arc(origin_x, origin_y, 4, 0, 2 * Math.PI);
        context.closePath();
        context.fillStyle = "white";
        context.fill();
    };

    // animate baby!
    // call the draw_light function repeatedly using requestAnimationFrame(draw_light)
    let update_the_light = function(t){
        draw_light(t/1000, the_lighthouse, ctx);
        requestAnimationFrame(update_the_light);
    };
    update_the_light(0);
</script> 
</body>
</html>

